// CustomPacket.h
#ifndef CUSTOM_PACKET_H
#define CUSTOM_PACKET_H

#include <cstdint>
#include <cstring>
#include <iostream>
#include <map>
#include <sys/types.h>
#include <vector>

// flags:
// bit7| bit6 |   bit5  |    bit4    |   bit3   | bit2  |bit1 |  bit0
// enc |error |msg_type |start_trans |end_trans |series |ACK  |URGENT

// msg_type: 0 text, 1 file
// to fully ask for end of transmition we send URGENT bit and end_trans bit

struct CustomPacket {
  uint16_t packet_id;
  uint8_t flags = 0;
  uint16_t length;
  char payload[256];
  uint16_t checksum;

  static std::map<u_int16_t, CustomPacket>
  fragmentMessage(const std::string &message, u_int16_t &packet_id, const bool &is_file = false);
  static std::string
  composedMessage(std::map<uint16_t, CustomPacket> &map_packets);
  static void incrementPacketId(uint16_t &packet_id);

  uint16_t calculateChecksum() const;
  void serialize(uint8_t *buffer) const;
  static CustomPacket deserialize(const uint8_t *buffer);
  bool getMsgType() const;
  void setMsgType(int msgType);
  void set_start_transmition_flag();
  bool get_start_transmition_flag() const;
  void set_end_transmition_flag();
  bool get_end_transmition_flag() const;
  void set_serialize_flag();
  bool get_serialize_flag() const;
  void set_ack_flag();
  bool get_ack_flag() const;
  void set_urgent_flag();
  bool get_urgent_flag() const;
  void set_error_flag();
  bool get_error_flag() const;

  //debug
  void printFlags() const;

;
};

#endif
#include "CustomPacket.h"
#include "MissingPacketsException.h"
#include <algorithm>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <map>
#include <vector>
#include <string>
#include <sys/types.h>
#include <bitset>
#include <fstream>
#include <sstream>

// Added function for increment because i was repeating myself
void CustomPacket::incrementPacketId(uint16_t &packet_id) {
  packet_id += 1;
  if (packet_id >= UINT16_MAX - 1) {
    std::cerr << "Warning: Packet ID overflow. Resetting...\n";
    packet_id = 0;
  }
}

uint16_t CustomPacket::calculateChecksum() const{
  uint32_t sum = 0;
  const uint8_t *data = reinterpret_cast<const uint8_t *>(this);
  for (size_t i = 0; i < sizeof(*this) - sizeof(this->checksum); ++i) {
    sum += data[i];
  }
  return static_cast<uint16_t>(sum & 0xFFFF);
}

void CustomPacket::serialize(uint8_t *buffer) const {
  memcpy(buffer, this, sizeof(CustomPacket));
}

CustomPacket CustomPacket::deserialize(const uint8_t *buffer) {
  CustomPacket packet;
  memcpy(&packet, buffer, sizeof(CustomPacket));
  return packet;
}

// SETS CONTEXT TYPE: MESSAGE OR FILE
// 0 for msg and 1 for file
bool CustomPacket::getMsgType() const { return (bool)((flags >> 5) & 0x01); }

void CustomPacket::setMsgType(int msgType) {
  // clears it if msgType = 0 -> text
  if (msgType == 0) {
    flags &= ~0x20;

    // or it sets it to 1 the 5th bit(starting from 0) if the package is part of
    // a file
  } else if (msgType == 1) {
    flags |= 0x20;
  } else {
    std::cerr << "Invalid msgType value!! Only 0 and 1 accepted.\n";
  }
}

// error flag (the one that will contain missing packets)
void CustomPacket::set_error_flag() {flags |= 0x01 << 6;}
bool CustomPacket::get_error_flag() const {return (flags & (0x01 << 6)) != 0;}

// start transmition flag -> the 4th bit
void CustomPacket::set_start_transmition_flag() { flags |= 0x10; }
bool CustomPacket::get_start_transmition_flag() const {
  return (flags & 0x10) != 0;
}

// end transmition flag the 3rd bit
void CustomPacket::set_end_transmition_flag() { flags |= 0x08; }
bool CustomPacket::get_end_transmition_flag() const {
  return (flags & 0x08) != 0;
}

// serialize bit flag; the 2nd bit
void CustomPacket::set_serialize_flag() { flags |= 0x04; }
bool CustomPacket::get_serialize_flag() const { return (flags & 0x04) != 0; }

// acknowledgement flag; the 1st bit
void CustomPacket::set_ack_flag() { flags |= 0x02; }
bool CustomPacket::get_ack_flag() const { return (flags & 0x02) != 0; }

// urgent flag -> check and set; the 0th bit
void CustomPacket::set_urgent_flag() { flags |= 0x01; }
bool CustomPacket::get_urgent_flag() const { return (flags & 0x01) != 0; }

//---------------------------------------------------------------------------
// Fragment a message into multiple packets
// It does add packet id because it was needed (switched to map)
// It does add checksumm so that all is done here
std::map<u_int16_t, CustomPacket>
CustomPacket::fragmentMessage(const std::string &message,
                              u_int16_t &packet_id, const bool &is_file) {

  std::map<u_int16_t, CustomPacket> packets;
  size_t maxPayloadSize = 256;
  size_t offset = 0;

    //-----------FOR MSG-------------
  if (is_file == false) {

    size_t totalLength = message.size() + 1;
    // Calculating the number of packets that will be needed to be send for this
    // message
    int number_of_packages_to_be_sended =
        (totalLength + maxPayloadSize - 1) / maxPayloadSize;

    // Creating the first packet that contains the size of the big message; It
    // will have 2 flags on : serialize and start transmition flag
    if (number_of_packages_to_be_sended > 1) {
      CustomPacket start_packet;

      start_packet.set_start_transmition_flag();
      start_packet.set_serialize_flag();

      std::string length_ser = std::to_string(number_of_packages_to_be_sended);
      memcpy(start_packet.payload, length_ser.data(), length_ser.length());
      start_packet.payload[length_ser.length()] = '\0'; // Add null terminator
      start_packet.length = length_ser.length() + 1; // Include null terminator in length

      CustomPacket::incrementPacketId(packet_id);
      start_packet.packet_id = packet_id;

      start_packet.checksum = start_packet.calculateChecksum();

      packets[packet_id] = start_packet;
    }

    while (offset < totalLength) {

      CustomPacket packet;

      // copying in memory in the current packet.payload the message string
      size_t length = std::min(maxPayloadSize, totalLength - offset);
      memcpy(packet.payload, message.data() + offset, length);

      // Setting length
      packet.length = length;
      offset += length;

      if (number_of_packages_to_be_sended > 1) {
        packet.set_serialize_flag();
      }

      if (offset >= totalLength) {
        packet.set_end_transmition_flag(); // Last packet
        // packet.payload[length] = '\0';
        // packet.length += 1;
      }

      CustomPacket::incrementPacketId(packet_id);
      packet.packet_id = packet_id;
      packet.checksum = packet.calculateChecksum();
      packets[packet_id] = packet;
    }

  }else {
    //-----------FOR FILE-------------
    //the msg will be the path
    std::string file_path = message;
    std::ifstream file(file_path, std::ios::binary);
    if (!file.is_open()) {
      {
        std::cerr << "Error: Could not open file: " << file_path << "\n";
      }
      //dont how what to return; null recommanded
      return packets;
    }


    // Extract file name and type
    std::string file_name = file_path.substr(file_path.find_last_of("/\\") + 1);
    std::string file_extension = file_name.substr(file_name.find_last_of('.') + 1);

    // Read the file content into a string
    std::ostringstream oss;
    oss << file.rdbuf();
    std::string file_content = oss.str();
    file.close();

    {
      std::cout << "File read successfully. Size: " << file_content.size() << " bytes\n";
    }

    //Starting packet
    size_t totalLength = file_content.size() + 1;
    int number_of_packages_to_be_sended = (totalLength + maxPayloadSize - 1) / maxPayloadSize + 1;
    CustomPacket start_packet;
    start_packet.set_start_transmition_flag();
    start_packet.set_serialize_flag();
    start_packet.setMsgType(1);

    std::string length_ser = std::to_string(number_of_packages_to_be_sended);
    memcpy(start_packet.payload, length_ser.data(), length_ser.length());
    start_packet.payload[length_ser.length()] = '\0'; // Add null terminator
    start_packet.length = length_ser.length() + 1; // Include null terminator in length

    CustomPacket::incrementPacketId(packet_id);
    start_packet.packet_id = packet_id;

    start_packet.checksum = start_packet.calculateChecksum();

    packets[packet_id] = start_packet;

    // Create a metadata packet
    std::string metadata = file_name + "|" + file_extension + "|" + std::to_string(file_content.size());
    CustomPacket metadata_packet;
    metadata_packet.set_serialize_flag();
    metadata_packet.setMsgType(1);
    memcpy(metadata_packet.payload, metadata.data(), metadata.size());
    metadata_packet.length = metadata.size();

    CustomPacket::incrementPacketId(packet_id);
    metadata_packet.packet_id = packet_id;

    metadata_packet.checksum = metadata_packet.calculateChecksum();

    // Send the metadata packet
    packets[packet_id] = metadata_packet;

    {
      std::cout << "Metadata packet sent: " << metadata << "\n";
    }

    while (offset < totalLength) {

      CustomPacket packet;

      // copying in memory in the current packet.payload the message string
      size_t length = std::min(maxPayloadSize, totalLength - offset);
      memcpy(packet.payload, file_content.data() + offset, length);

      // Setting length
      packet.length = length;
      offset += length;

      packet.set_serialize_flag();
      packet.setMsgType(1);

      if (offset >= totalLength) {
        packet.set_end_transmition_flag(); // Last packet
        // packet.payload[length] = '\0';
        // packet.length += 1;
      }

      CustomPacket::incrementPacketId(packet_id);
      packet.packet_id = packet_id;
      packet.checksum = packet.calculateChecksum();
      packets[packet_id] = packet;
    }
  }
  return packets;
}

//---------------------------------------------------------------------------------
// Checks if there is a start and end to this map and if the number of elements
// given in the first packet is the same with the number of elements received;
std::string CustomPacket::composedMessage(
    std::map<uint16_t, CustomPacket> &receivedPackets) {

  int expectedPacketCount = -1; // Unknown initially
  int receivedPacketCount = 0;
  uint16_t startPacketId = 0;
  bool hasEndPacket = false;

  // For the request back of the packages that did not make it
  std::vector<uint16_t> not_received_packages;

  for (auto it = receivedPackets.begin(); it != receivedPackets.end();) {
    const CustomPacket &packet = it->second;


    //we recalculate checksum and check if it has the same value
    if (packet.calculateChecksum() != packet.checksum) {
      std::cerr << "\nPacket with id: " << it->first << " has been compromised!\n\n";
      it = receivedPackets.erase(it);
      continue;

    }

    // If we find a start packet, extract the expected number of packets
    if (packet.get_start_transmition_flag()) {
      std::string countStr(packet.payload, packet.length - 1);
      std::cout<<"\n\nCountStr: "<<countStr<<", Of size: "<<countStr.length()<<std::endl;
      try {
        expectedPacketCount = std::stoi(countStr);
      } catch (...) {
        std::cerr << "Error: Invalid start packet format.\n";
        throw std::runtime_error("Invalid start packet format");
      }
      startPacketId = packet.packet_id; // Store its ID
      ++it;
      continue;                         // Do not add start packet to the map
    }

    receivedPacketCount++;

    if (packet.get_end_transmition_flag()) {
      hasEndPacket = true;
    }

    ++it;
  }

  std::cout << "Expected Packet Count: " << expectedPacketCount
            << ", Received Packet Count: " << receivedPacketCount
            << ", Has End Packet: " << std::boolalpha << hasEndPacket
            << ", hasEndPacket: " << hasEndPacket << std::endl;

  if (expectedPacketCount == -1) {
    std::cerr << "Error: No starting packet\n\t"
          "It is needed a starting packet to know the dimention of the message!!!\n"
          "\tSending request for a new starting packet.\n\n";
    throw MissingPacketsException(not_received_packages, true);
  }

  // Ensure we received all expected packets; care that if we have a short message
  // we will not have a start, end and serialise flag, and only the packetid

  //deleted:expectedPacketCount == -1 ||  
  if (receivedPacketCount != expectedPacketCount || !hasEndPacket) {
    std::cerr << "Error: Missing packets or end flag not received.\n";
    // throw MissingPacketsException(not_received_packages, expectedPacketCount == -1);
  }

  // Now, reconstruct the message
  std::string message;
  uint16_t i = startPacketId;

  for (const auto &pair : receivedPackets) {
    const CustomPacket &packet = pair.second;

    if (packet.packet_id != startPacketId){
      if (packet.get_end_transmition_flag()) {
        message.append(packet.payload, packet.length - 1);
      }else {
        message.append(packet.payload, packet.length);
      }
    }

    // We compare the id from received packets with the cnt we are keeping to check for missing packets;
    // for every new packet from the map we increment the i until it has the same value, 
    // spotting missing packets
    while (i != pair.first) {
      not_received_packages.push_back(i);
      CustomPacket::incrementPacketId(i);
      if (i == startPacketId) break;
    }

    CustomPacket::incrementPacketId(i);
  }

  //We try to use try catch first, waiting for results and trying new things
  if (!not_received_packages.empty()) {
    throw MissingPacketsException(not_received_packages, false);
  }

  return message;
}

void CustomPacket::printFlags() const {
  std::cout << "Flags (binary): " << std::bitset<8>(static_cast<unsigned int>(flags)) << "\n";
  std::cout << "  Encryption (enc): " << ((flags & (1 << 7)) != 0) << "\n";
  std::cout << "  Error: " << get_error_flag() << "\n";
  std::cout << "  Message Type (msg_type): " << getMsgType() << "\n";
  std::cout << "  Start Transmission (start_trans): " << get_start_transmition_flag() << "\n";
  std::cout << "  End Transmission (end_trans): " << get_end_transmition_flag() << "\n";
  std::cout << "  Serialize (series): " << get_serialize_flag() << "\n";
  std::cout << "  Acknowledgment (ACK): " << get_ack_flag() << "\n";
  std::cout << "  Urgent: " << get_urgent_flag() << "\n";
}
#ifndef PEER_H
#define PEER_H

#include "CustomPacket.h"
#include <mutex>
#include <vector>
#include <condition_variable>
#include <netinet/in.h>
#include <string>

class Peer {
public:

    std::vector<std::string> messages_received;
    bool is_connected = false, exiting = false;

    std::mutex is_connected_mutex;
    std::mutex cout_mutex;
    std::mutex adding_msg_received;
    std::mutex exiting_mutex;

    void startPeer();
    void connectToPeer(const char *remote_ip);

    void sendMessage(const std::string &msg);

    void sendFile(const std::string &file_path);
    void listenForPackets();
    void processPackets();
    void endConnection();

    std::string get_messages_received();
    bool confirm_file_received();

    void runTerminalInterface();

private:
    int sock;
    int serialise_packet_size = 0, procesed_packets = 0;
    int port=8081;
    bool requested_end_transmition = false;
    // bool client_addr_initialized = false; // Track if the client's address is initialized
    uint16_t packet_id = 0;
    bool connectToPeer_message_send = false;
    std::vector<uint16_t> missing_packets;

    std::string localIPAddress;

    //For dealing with error packets, i need to store for a while the packets
    // I will try to memorate a finite number of packets (1000)
    std::map<uint16_t, CustomPacket> packetsToBeSend;
    int size_of_packetsToBeSend = 1000;

    std::string folder_name = "data";

    //For seeing messages
    bool file_received = false;

    std::mutex packet_mutex;
    std::mutex packet_id_mutex;
    std::mutex packetsToBeSend_mutex;
    std::mutex checking_file_received;
    std::mutex requested_end_transmition_mutex;
    std::mutex connectToPeer_message_send_mutex;

    // Declare cout_mutex as extern

    
    std::vector<CustomPacket> packet_vector;
    std::condition_variable packet_cv;
    std::condition_variable messages_received_cv;
    std::condition_variable checking_file_received_cv;

    sockaddr_in peer_addr, client_addr;

    void sendPacket(const CustomPacket &packet);
    void receivePacket(CustomPacket &packet);
    void composePacketMessage();
    void composePacketFile();
    void sendPacketFile();

    //new debugging method
    void sendPacketTo(const CustomPacket &packet, const struct sockaddr_in &dest_addr);
    void incrementing_and_checking_packet_id(const uint16_t idpacket);
    CustomPacket create_ack_packet();
    CustomPacket create_error_packet(const uint16_t &missing_packet_id);
    CustomPacket create_start_packet(const int &size, const bool &isFile = false);

    //For memoring the packets that will be send
    void add_packets_to_history(const std::map<uint16_t, CustomPacket> &packet_list);

    //For adding complete messages in vector
    void adding_messages_in_received_messages(const std::string &msg);

    void ensureDataFolderExists();
    std::string getLocalIPAddress() const;
    int connectToAvailablePort();
    void print_commands_options();
};

#endif // PEER_H#include <arpa/inet.h>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <thread>
#include <unistd.h>
#include <map>
#include <mutex>
#include <queue>
#include <chrono>
#include <condition_variable>

#include <fstream>
#include <sstream>
#include <sys/stat.h>  // For mkdir
#include <sys/types.h> // For mkdir
#include <filesystem>  // For checking if the folder exists (C++17)
#include <ifaddrs.h>
#include <netdb.h>

//For input select reader
#include "Peer.h"
#include "CustomPacket.h"

void Peer::sendPacket(const CustomPacket &packet) { 
  {
  // Debug: Print the destination address
  char dest_ip[INET_ADDRSTRLEN];
  inet_ntop(AF_INET, &(client_addr.sin_addr), dest_ip, INET_ADDRSTRLEN);
  std::cout << "Sending packet to " << dest_ip << ":" << ntohs(client_addr.sin_port) << "\n";
  }

  
  // Allocate buffer for IP header + payload
  uint8_t buffer[sizeof(struct iphdr) + sizeof(CustomPacket)];

  // Construct the IP header
  struct iphdr *ip_header = (struct iphdr *)buffer;
  ip_header->version = 4; // IPv4
  ip_header->ihl = 5; // Header length (5 * 4 = 20 bytes)
  ip_header->tos = 0; // Type of service
  ip_header->tot_len = htons(sizeof(buffer)); // Total length (header + payload)
  ip_header->id = htons(packet.packet_id); // Identification
  ip_header->frag_off = 0; // No fragmentation
  ip_header->ttl = 64; // Time to live
  ip_header->protocol = IPPROTO_RAW; // Protocol (raw socket)
  ip_header->check = 0; // Checksum (set to 0 for now, kernel may calculate it)
  ip_header->saddr = inet_addr(localIPAddress.c_str()); // Source IP address
  ip_header->daddr = client_addr.sin_addr.s_addr; // Destination IP address

  // Copy the payload (CustomPacket) into the buffer after the IP header
  packet.serialize(buffer + sizeof(struct iphdr));
  
  incrementing_and_checking_packet_id(packet.packet_id);
  ssize_t bytes_sent = sendto(sock, buffer, sizeof(buffer), 0, (struct sockaddr *)&client_addr, sizeof(client_addr));

  {
    std::lock_guard<std::mutex> lock(cout_mutex);

    if (bytes_sent < 0) {
      std::cerr << "Error sending packet with ID " << packet.packet_id << "\n" << bytes_sent << std::endl;
    } else {
      std::cout << "Packet with ID " << packet.packet_id << " sent successfully.\n";
    }
  }
}

//-------------------------------------------------------------------------------------------------------
void Peer::startPeer() {

  this->localIPAddress = getLocalIPAddress();
  if (localIPAddress == "") {
      {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "Cannot get IPAddress!!";
      }
      return;
  }else {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "IP Address: " << localIPAddress << std::endl;
  }

  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "startPeer called with port: " << this->port << "\n";
  }

  sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
  if (sock < 0) {
    perror( "Error creating socket");
    return;
  }

  peer_addr.sin_family = AF_INET;
  peer_addr.sin_port = htons(this->port);

  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout<< "Server mode" << std::endl;
  }
  peer_addr.sin_addr.s_addr = INADDR_ANY;

  if (bind(sock, (struct sockaddr *)&peer_addr, sizeof(peer_addr)) < 0) {
    perror("Error binding socket");
    std::cerr << "Error: Failed to bind socket to port " << port << std::endl;
    close(sock);
    return;
  }

  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout<< "Server mode initialized.\n";
  }

}

//-------------------------------------------------------------------------------------------------------
void Peer::receivePacket(CustomPacket &packet) {

  uint8_t buffer[sizeof(struct iphdr) + sizeof(CustomPacket)];
  socklen_t addr_len = sizeof(peer_addr);

  ssize_t bytes_read = recvfrom(sock, buffer, sizeof(buffer), 0,
                                (struct sockaddr *)&peer_addr, &addr_len);

  if (bytes_read <= 0) {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "Error reading from socket.\n";
    return;
  }else {
    // std::lock_guard<std::mutex> lock(cout_mutex);
    // std::cout<< "I have received a packet!\n";
  }

  packet = CustomPacket::deserialize(buffer + sizeof(struct iphdr));
}

//-------------------------------------------------------------------------------------------------------
void Peer::listenForPackets() {

  while (true) {

    //End thread on receiving the signal
    {
      std::lock_guard<std::mutex> lock(exiting_mutex);
    if (exiting) break;
    }

    CustomPacket packet;
    receivePacket(packet);

    if (packet.length == 0) {
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      continue;
    }
    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout<<"Received a packet\n";
    }
     // Validate the packet
    if (packet.calculateChecksum() != packet.checksum) {
      {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cerr << "\n\n!!! Packet with ID " << packet.packet_id
                  << " is corrupted !!!!\n\n\n";
      }
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      continue;
    }

    bool var_is_connected;
    {
      std::lock_guard<std::mutex> lock(is_connected_mutex);
      var_is_connected = this->is_connected;
    }

    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout << "Received a packet; isconnected: " << var_is_connected <<"\npacket size: " << 
      packet.length<< std::endl;
      packet.printFlags();
    }

    // Sequence for responding to a connection request
    if (!var_is_connected) {
      if (packet.get_urgent_flag() && packet.get_start_transmition_flag()) {
        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout << "Received initial connection packet. Responding with acknowledgment.\n";
        }

        // Store the client's address
        client_addr = peer_addr;
        // client_addr_initialized = true;

        incrementing_and_checking_packet_id(packet.packet_id);
        sendPacket(create_ack_packet());

        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout << "Sent acknowledgment packet.\n";
        }

        // Mark the peer as connected
        {
          std::lock_guard<std::mutex> lock(is_connected_mutex);
          this->is_connected = true;
        }
        continue;

        //Checking if we received ack for us trying to connect to someone
      } else if (packet.get_urgent_flag() && packet.get_ack_flag()){

        bool var = false;
        {
          std::lock_guard<std::mutex> lock(connectToPeer_message_send_mutex);
          var = this->connectToPeer_message_send;
        }

        if (var) {
          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "Connection established with remote peer.\n";
          }
          
          {
            std::lock_guard<std::mutex> lock(is_connected_mutex);
            this->is_connected = true;
          }
          incrementing_and_checking_packet_id(packet.packet_id);

          {
            std::lock_guard<std::mutex> lock(connectToPeer_message_send_mutex);
            this->connectToPeer_message_send = false;
          }
        }else {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout << "Unexpected packet received before connection was established. Ignoring.\n\n";
        }
        continue;
      }else {
        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout << "Unexpected packet received before connection was established. Ignoring.\n\n";
        }
      }
    } else {

        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout << "\nIs connected branch\n";
          std::cout<< "Processing packet: " << packet.packet_id<< std::endl;
          packet.printFlags();
          std::cout<<std::endl;
        }
      std::this_thread::sleep_for(std::chrono::milliseconds(100));



      //if it is already connected, but it still tries to connect to it (from some reason)
      // TODO: we need to send 1 more packet in this sequence to be sore that we bouth end it.
      if (packet.get_urgent_flag() && packet.get_start_transmition_flag()) {
        std::lock_guard<std::mutex> lock (cout_mutex);
        std::cout<<"Received again a start transmition!\n\tIgnorring...\n";
        continue;
      }
      
      // If end transmition sequense started the initiation
      if (packet.get_urgent_flag() && packet.get_end_transmition_flag()) {
        {
          std::lock_guard<std::mutex> lock (cout_mutex);
          std::cout<< "Received end transmition packet. Responding...\n";
        }
        
        incrementing_and_checking_packet_id(packet.packet_id);
        sendPacket(create_ack_packet());
        {
          std::lock_guard<std::mutex> lock (cout_mutex);
          std::cout<< "Sended packet with ack of end transmition...:\n";
        }

        {
          std::lock_guard<std::mutex> lock (is_connected_mutex);
          this->is_connected = false;
        }

        {
          std::lock_guard<std::mutex> lock(exiting_mutex);
          this->exiting = true;
        }


        // Close the socket
        close(sock);

        //Creating mock packet so that we dont block the processPackets
        CustomPacket mock_packet;
        {
          std::lock_guard<std::mutex> lock(packet_mutex);
          packet_vector.push_back(mock_packet);
          packet_cv.notify_one();
        }

        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout << "Socket closed.Sended mock packet to close the processPackets.\n";
        }

        return;
      }

      //Responding to a missing packet from the serialise message
      // TODO: Check if it works with text message and file!!!
      if (packet.get_error_flag() && packet.get_serialize_flag()) {
        if (packet.packet_id <= packet_id) {
          {
            std::lock_guard<std::mutex> lock (cout_mutex);
            std::cout << "Received a packet that has info about packets that did not make it\n\t";
          }

          {
            std::lock_guard<std::mutex> lock(packetsToBeSend_mutex);
            auto it = packetsToBeSend.find(packet.packet_id);

            if (it != packetsToBeSend.end()){
              sendPacket(it->second);
            }else {
              std::lock_guard<std::mutex> lock(cout_mutex);
              std::cout<<"The packet that did not make it is not in the history anymore\n";
            }
          }
        }else {
          std::lock_guard<std::mutex> lock (cout_mutex);
          std::cout << "Received an error packet with id to big!! IGNORING!\n";
        }

        continue;
      }

      if (packet.get_urgent_flag() && packet.get_ack_flag()) {
        bool var_req_end = false;
        {
          std::lock_guard<std::mutex> lock(requested_end_transmition_mutex);
          var_req_end = this->requested_end_transmition;
        }

        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout<<"Ack packet received\n";
        }

        if (var_req_end) {
          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "Connection successfully ended.\n";
          }

          // Close the socket
          close(sock);
          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "socket closed.\n";
          }
          {
            std::lock_guard<std::mutex> lock(exiting_mutex);
            this->exiting = true;
          }

          //Creating mock packet so that we dont block the processPackets
          CustomPacket mock_packet;
          {
            std::lock_guard<std::mutex> lock(packet_mutex);
            packet_vector.push_back(mock_packet);
            packet_cv.notify_one();
          }
          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "sended mocking packet";
          }

        {
          std::lock_guard<std::mutex> lock(requested_end_transmition_mutex);
          this->requested_end_transmition = false;
        }

          std::this_thread::sleep_for(std::chrono::milliseconds(100));

          return;
        }

        continue;
      }

      {
      // Add the packet to the queue
        std::lock_guard<std::mutex> lock(packet_mutex);
        packet_vector.push_back(packet);
        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout<<"Added the packet with id: " << packet.packet_id << " in the packet_vector.\n";
        }
        packet_cv.notify_one(); // Notify the processing thread
      }
    }
  }
}

//-------------------------------------------------------------------------------------------------------
void Peer::processPackets() {
  std::map<uint16_t, std::string> msg_log;
  std::map<uint16_t, std::string> long_message;
  std::string msg = "";
  u_int16_t start = UINT16_MAX, end = UINT16_MAX;
  std::vector<CustomPacket> procesed_packets_memory;

  std::string file_name, file_extension;
  size_t file_size = 0;
  std::ostringstream file_content;
  
  while (true) {

    CustomPacket packet;

    // Wait for a packet to be available
    {
      std::unique_lock<std::mutex> lock(packet_mutex);
      packet_cv.wait(lock, [this] { return !packet_vector.empty(); });

      //End thread on receiving the signal
      {
        std::lock_guard<std::mutex> lock(exiting_mutex);
        if (exiting){
          {
            std::lock_guard<std::mutex> lock(adding_msg_received);
            messages_received.push_back("Aw12@0986^12luAwCluhWQ123~~``!");
            messages_received_cv.notify_one();
            {
              std::lock_guard<std::mutex> lock(cout_mutex);
              std::cout<<"Received mocking packet. Sending wierd message.\n";
            }
          }
          break;
        }
      }

      {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "Processing a packet from the queue.\nSize: " << packet_vector.size() << std::endl;
      }

      // Get the next packet from the queue
      packet = *packet_vector.begin();
      packet_vector.erase(packet_vector.begin());
    }

    // I will do this in listen for packets
    // // Validate the packet
    // if (packet.calculateChecksum() != packet.checksum) {
    //   {
    //     std::lock_guard<std::mutex> lock(cout_mutex);
    //     std::cerr << "\n\n!!! Packet with ID " << packet.packet_id
    //               << " is corrupted !!!!\n\n\n";
    //   }
    //   continue;
    // }

    // Process the packet (e.g., add to a map, reconstruct a message, etc.)
    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout << "Processing Packet ID: " << packet.packet_id << "\n";
      // std::cout << "Payload: " << packet.payload << "\n";
    }

    if (!packet.get_serialize_flag()) {
      //-------------nonserialize-----------------

    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout << "Single packet.\n";
    }

      std::string msg = std::string(packet.payload, packet.length);
      msg_log.emplace(packet.packet_id, msg);

      //For showing in interface
      adding_messages_in_received_messages(msg);
      
      incrementing_and_checking_packet_id(packet.packet_id);

      while (packet_id < packet.packet_id) {
        missing_packets.push_back(packet_id);
        incrementing_and_checking_packet_id(packet.packet_id);
      }
      
      if (!missing_packets.empty()) {

      {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "Not all packets are received!\tSending the missing packets";
      }

        for (const auto &it : missing_packets) {
          sendPacket(create_error_packet(it));
          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "Sending request for resend for: " << static_cast<int>(it);
          }
        }
        {
          std::lock_guard<std::mutex> lock(packet_mutex);
          packet_vector.insert(packet_vector.begin(), procesed_packets_memory.begin(), procesed_packets_memory.end());
        }
        procesed_packets_memory.clear();
        missing_packets.clear();
        packet_cv.notify_one();

        continue;
      }

    }else {

      // ------------serialise section--------------------------
      {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout<< "Got to the serialize section.\n";
      }

      procesed_packets_memory.push_back(packet);

      //-----------------Text message-------------------
      if (packet.getMsgType() == 0) {

        // We will itinitate the serialise packet size if we didnt already
        if (packet.get_start_transmition_flag() && serialise_packet_size == 0) {
          serialise_packet_size = std::stoi(std::string(packet.payload, packet.length));
          start = packet.packet_id;
          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout<< "\tFoud the start transmition packet. Number of packets in this train is: " << serialise_packet_size << std::endl;
          }

          incrementing_and_checking_packet_id(start);

          for (uint16_t val = start + 1; val <= start + serialise_packet_size; val++) {
            missing_packets.push_back(val);
          }

          continue;
        }else if (packet.get_start_transmition_flag()){
          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout<< "\n\nWe found a second start packet with start transmition !!! \n\n";
          }

          continue;

        }

        for (auto it = missing_packets.begin(); it != missing_packets.end(); ) {
            if (*it == packet.packet_id) {
                it = missing_packets.erase(it); // Erase returns the next iterator
            } else {
                ++it; // Increment the iterator only if no element is erased
            }
        }

        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout<< "We are adding the packet "<< packet.packet_id <<" in the big message!\n";
        }

        //The first packet (the one with the start) has in payload the number of packets from that 
        if (long_message.find(packet.packet_id) == long_message.end() && serialise_packet_size != 0) {
          long_message.emplace(packet.packet_id, std::string(packet.payload, packet.length));
          procesed_packets++; 
        }else {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout<< "\n\n\tWe have a duplicate\n\n\n";
        }

        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout<< "\n\nsize_long_msg: " << serialise_packet_size << " ; packets processed: " <<procesed_packets << std::endl;
        }

        if (serialise_packet_size != 0 && serialise_packet_size == procesed_packets) {
          for (int i = 1; i <serialise_packet_size + 1; ++i) {
            uint16_t current_packet_id = start + i;

            auto it = long_message.find(current_packet_id);
            if (it != long_message.end()) {
              msg += it->second;
            }else {
              {
                std::lock_guard<std::mutex> lock(cout_mutex);
                std::cout<< "Missing packet: " << current_packet_id << std::endl;
              }
              // missing_packets.push_back(current_packet_id);
            }
          }

          // if (!missing_packets.empty()) {
          //   {
          //     std::lock_guard<std::mutex> lock(cout_mutex);
          //     std::cout<< "There are missing packets!\n";
          //   }
          //   {
          //     std::lock_guard<std::mutex> lock(packet_mutex);
          //     packet_vector.insert(packet_vector.begin(), procesed_packets_memory.begin(), procesed_packets_memory.end());
          //   }

          //   for (uint16_t val : missing_packets) {
          //     sendPacket(create_error_packet(val));
          //   }
          //   procesed_packets_memory.clear();
          //   packet_cv.notify_one();

          //   missing_packets.clear();

          //   // throw missing_packets;
          // }

          long_message.clear();
          start = UINT16_MAX;
          serialise_packet_size = 0;
          procesed_packets = 0;
          procesed_packets_memory.clear();

          if (packet.getMsgType() == 1){
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "\tBIG MESSAGE:\n\t" << msg << "\n";
          }else {

          }

          //For showing it in interface
          adding_messages_in_received_messages(msg);

          // Nush sigur; nu pare deloc eficient sa folosesc acelasi tip de packet pentru date binare:/


          msg.clear();
        }

      } else {
        // -----------FILE TYPE-------------------

        if (packet.get_start_transmition_flag() && serialise_packet_size == 0) {
          serialise_packet_size = std::stoi(std::string(packet.payload, packet.length));
          start = packet.packet_id;
          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout<< "\tFoud the start transmition packet. Number of packets in this train is: " << serialise_packet_size << std::endl;
          }

          incrementing_and_checking_packet_id(start);


          //I will add all the packets that are needed to get in in missing packets and I will remove them 
          // from the vector when they arrive
          for (auto it = missing_packets.begin(); it != missing_packets.end(); ) {
              if (*it == packet.packet_id) {
                  it = missing_packets.erase(it); // Erase returns the next iterator
              } else {
                  ++it; // Increment the iterator only if no element is erased
              }
          }

          continue;
        }else if (packet.get_start_transmition_flag()){
          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout<< "\n\nWe found a second start packet with start transmition !!! \n\n";
          }

          continue;

        }

        for (uint16_t it : missing_packets) {
          if (it == packet.packet_id) missing_packets.erase(missing_packets.begin() + it);
        }
        // auto it = std::find(missing_packets.begin(), missing_packets.end(), packet.packet_id);
        // if (it != missing_packets.end()) {
        //   missing_packets.erase(it);
        // }else {
        //   std::lock_guard <std::mutex> lock(cout_mutex);
        //   std::cout<<"We tried to delete a packet from missing packets that was not in the range\n\n";
        // }

        // Process metadata packet; First packet after the size packet is the one with metadata
        if (file_name.empty()) {
            std::string metadata(packet.payload, packet.length);
            size_t pos1 = metadata.find('|');
            size_t pos2 = metadata.find('|', pos1 + 1);

            file_name = metadata.substr(0, pos1);
            file_extension = metadata.substr(pos1 + 1, pos2 - pos1 - 1);
            file_size = std::stoul(metadata.substr(pos2 + 1));

            {
              std::lock_guard<std::mutex> lock(cout_mutex);
              std::cout << "Received metadata: File Name: " << file_name
                        << ", File Extension: " << file_extension
                        << ", File Size: " << file_size << " bytes\n";
            }

            long_message[packet.packet_id] = metadata;
            procesed_packets++;

            continue;
        }

        // We add all the content message dirrecly in the long_message var
        long_message[packet.packet_id] = std::string(packet.payload, packet.length);
        procesed_packets++;

        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout<<"Added content in the file\n";
          std::cout<<"\tprocessed packets : " << procesed_packets 
              << "\n\tserialize_packet_size: " << serialise_packet_size<<std::endl;
        }

        // If the size is met, we create the file and add the content in it.
        if (procesed_packets == serialise_packet_size) {
        {
          std::lock_guard<std::mutex> lock(cout_mutex);
          std::cout<<"all files received\n";
        }

          bool metadata_check = true;
          for (auto it = long_message.begin(); it!= long_message.end(); ++it) {
            if (metadata_check) {
              {
                std::lock_guard<std::mutex> lock(cout_mutex);
                std::cout<<"Ignorring metadata\n";
              }
              metadata_check = false;
              continue;
            }

            std::string content = it->second;

            if (it == std::prev(long_message.end())) {
              content.pop_back();
            }

            file_content << content;
          }
          // for (auto &pair : long_message) {
          //   if (metadata_check) {
          //     {
          //       std::lock_guard<std::mutex> lock(cout_mutex);
          //       std::cout<<"Ignorring metadata\n";
          //     }
          //     metadata_check = false;
          //     continue;
          //   }

          //   if (pair == std::prev(long_message.end())) {
          //     std::string content = pair.second;
          //     content = content.pop_back();
          //     file_content << content;
          //     break;
          //   }
          //   file_content << pair.second;
          // }

          // Write the file to disk
          ensureDataFolderExists();

          std::string relative_path = folder_name + "/" + file_name;
          std::ofstream output_file(relative_path, std::ios::binary);
          if (output_file.is_open()) {
              output_file << file_content.str();
              output_file.close();

              {
                  std::lock_guard<std::mutex> lock(cout_mutex);
                  std::cout << "File reassembled and saved as: " << file_name << "\n";
              }
          } else {
              {
                  std::lock_guard<std::mutex> lock(cout_mutex);
                  std::cerr << "Error: Could not create file: " << file_name << "\n";
              }
          }

          // Clear the buffers
          long_message.clear();
          file_content.str("");
          file_content.clear();
          file_name.clear();
          file_extension.clear();
          file_size = 0;
          serialise_packet_size = 0;
          procesed_packets = 0;
          procesed_packets_memory.clear();

          // // Reprint the commands
          // {
          //     std::lock_guard<std::mutex> lock(cout_mutex);
          //     std::cout << "\nCommands:\n";
          //     std::cout << "1. Send message\n";
          //     std::cout << "2. Send file\n";
          //     std::cout << "3. Exit\n";
          //     std::cout << "Enter your choice: \n";
          // }

          print_commands_options();
        }

      }

    }

    incrementing_and_checking_packet_id(packet.packet_id);
  }
}

//-------------------------------------------------------------------------------------------------------
void Peer::sendMessage(const std::string &msg) {
  std::map<uint16_t, CustomPacket> packet_list =
      CustomPacket::fragmentMessage(msg, packet_id);

  // I will add it to the new buffer to deal with the error packet if need be
  add_packets_to_history(packet_list);
  
  bool check = false;

  for (const auto &pair : packet_list) {
    const CustomPacket &packet = pair.second;
    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout << "Sending Packet ID: " << packet.packet_id << "\n";
      std::cout << "Payload to be send: " << packet.payload << "\n";

    }

    // if (!check) {
    //   std::lock_guard<std::mutex> lock(cout_mutex);
    //   std::cout << "Skiping once\n";
    //   check = true;
    // }else {
    // }
    sendPacket(packet);
  }
}

//-------------------------------------------------------------------------------------------------------
void Peer::sendFile(const std::string &file_path) {
  std::map<uint16_t, CustomPacket> packet_list = CustomPacket::fragmentMessage(file_path, packet_id, true);

  // I will add it to the new buffer to deal with the error packet if need be
  add_packets_to_history(packet_list);
  
  bool check = false;

  for (const auto &pair : packet_list) {
    const CustomPacket &packet = pair.second;
    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout << "\n\nSending Packet ID: " << packet.packet_id << "\n";
      std::cout << "Payload to be send: " << packet.payload << "\n";
      packet.printFlags();
      std::cout<<std::endl;

    }

    // if (!check) {
    //   std::lock_guard<std::mutex> lock(cout_mutex);
    //   std::cout << "Skiping once\n";
    //   check = true;
    // }else {
    // }
    
    sendPacket(packet);
  }
}


//STARTING AND ENDING CONNECTION
//-------------------------------------------------------------------------------------------------------
void Peer::connectToPeer(const char *remote_ip) {
  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "Client is attempting to connect to " << remote_ip << "...\n";
  }

  // Set up the destination address
  peer_addr.sin_family = AF_INET;
  peer_addr.sin_port = htons(this->port); // port
  if (inet_pton(AF_INET, remote_ip, &peer_addr.sin_addr) <= 0) {
    std::cerr << "Invalid address/Address not supported: " << remote_ip << "\n";
    return;
  }

  client_addr = peer_addr;
  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "Sent initial packet with urgent and start_transmission flags.\n";
  }
  packet_id = 0;

  // Create the initial packet with urgent and start_transmission flags
  CustomPacket start_packet;
  start_packet.packet_id = packet_id;
  start_packet.set_urgent_flag();
  start_packet.set_start_transmition_flag();

  std::string msg= "HELLO!";
  memcpy(start_packet.payload, msg.data(), msg.size());
  start_packet.length = msg.size();
  start_packet.checksum = start_packet.calculateChecksum();

  // Send the initial packet
  sendPacket(start_packet);

  {
    std::lock_guard<std::mutex> lock(connectToPeer_message_send_mutex);
    this->connectToPeer_message_send = true;
  }

  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "Sent initial packet with urgent and start_transmission flags.\n";
  }

  // Wait for a response packet with urgent and ack flags
  // CustomPacket response_packet;
  // while (true) {
  //   receivePacket(response_packet);

  //   if (response_packet.get_urgent_flag() && response_packet.get_ack_flag()) {
  //     std::lock_guard<std::mutex> lock(cout_mutex);
  //     std::cout << "Received acknowledgment packet from the server.\n";
  //     incrementing_and_checking_packet_id(response_packet.packet_id);
  //     break;
  //   } else {
  //     std::lock_guard<std::mutex> lock(cout_mutex);
  //     std::cout << "?Received a packet, but it does not have the expected flags. Waiting...\n";
  //   }
  // }

  // {
  //   std::lock_guard<std::mutex> lock(cout_mutex);
  //   std::cout << "Connection established with remote peer at " << remote_ip << ".\n";
  // }
  
  // {
  //   std::lock_guard<std::mutex> lock(is_connected_mutex);
  //   this->is_connected = true;
  // }
}

//-------------------------------------------------------------------------------------------------------
// I need to send another message: when i receive a request to end the socket, i need to send an 
// ack packet and w8 to see if that packet gets to the user. If i dont, the iniciator can wait for
// my ack and never get it.
void Peer::endConnection() {
  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "Attempting to end the connection...\n";
  }

  // Create the end connection packet
  CustomPacket end_packet;
  {
    std::lock_guard<std::mutex> lock(packet_id_mutex);
    end_packet.packet_id = packet_id;
    end_packet.set_urgent_flag();
    end_packet.set_end_transmition_flag();
    std::string msg= "end";
    memcpy(end_packet.payload, msg.data(), msg.size());

    end_packet.length = msg.size();
    end_packet.checksum = end_packet.calculateChecksum();
  }

  {
    std::lock_guard<std::mutex> lock(requested_end_transmition_mutex);
    this->requested_end_transmition = true;
  }
  std::this_thread::sleep_for(std::chrono::milliseconds(100));

  // Send the end connection packet
  sendPacket(end_packet);

  // {
  //   std::lock_guard<std::mutex> lock(exiting_mutex);
  //   this->exiting = true;
  // }

  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "Sent end connection packet with ID: " << end_packet.packet_id << "\n";
    end_packet.printFlags();
  }

  // Wait for acknowledgment
  // CustomPacket response_packet;
  // while (true) {
  //   receivePacket(response_packet);

  //   if (response_packet.get_urgent_flag() && response_packet.get_ack_flag()) {
  //     {
  //       std::lock_guard<std::mutex> lock(cout_mutex);
  //       std::cout << "\nReceived acknowledgment for end connection packet.\n";
  //     }
  //     break;
  //   } else {
  //     {
  //       std::lock_guard<std::mutex> lock(cout_mutex);
  //       std::cout << "\n\nReceived a packet in waiting for ack, but it does not have the expected flags. Waiting...\n";
  //     }
  //   }
  // }

  // Mark the connection as disconnected
  // {
  //   std::lock_guard<std::mutex> lock(cout_mutex);
  //   std::cout << "Connection successfully ended.\n";
  // }
  
  // {
  //   std::lock_guard<std::mutex> lock(is_connected_mutex);
  //   this->is_connected = false;
  // }

  // // Close the socket
  // close(sock);
  // {
  //   std::lock_guard<std::mutex> lock(cout_mutex);
  //   std::cout << "socket closed.\n";
  // }

  // // For checking functionality and contents (debug)
  // {
  //   std::lock_guard<std::mutex> lock(packetsToBeSend_mutex);

  //   for (const auto &[key, val] : packetsToBeSend) {
  //     std::lock_guard<std::mutex> lock(cout_mutex);
  //     std::cout << key << "; " << std::string(val.payload, val.length) << "\n";
  //   }
  // }

}
//-------------------------------------------------------------------------------------------------------
CustomPacket Peer::create_ack_packet() {

  // Create the acknowledgment packet
  CustomPacket ack_packet;
  {
    std::lock_guard<std::mutex> lock(packet_id_mutex);
    ack_packet.packet_id = packet_id;
  }
  ack_packet.set_urgent_flag();
  ack_packet.set_ack_flag();
  std::string msg= "ack";
  memcpy(ack_packet.payload, msg.data(), msg.size());
  ack_packet.length = msg.size();
  ack_packet.checksum = ack_packet.calculateChecksum();

  return ack_packet;

}
//-------------------------------------------------------------------------------------------------------
CustomPacket Peer::create_start_packet(const int &size, const bool &isFile) {
  CustomPacket packet;
  packet.set_start_transmition_flag();
  packet.set_serialize_flag();
  isFile == 1 ? packet.setMsgType(1) : packet.setMsgType(0);

  std::string string_size = std::to_string(size);
  memcpy(packet.payload, string_size.data(), string_size.length());
  packet.payload[string_size.length()] = '\n';
  packet.length = string_size.length() + 1;
  packet.packet_id = this->packet_id;
  packet.checksum = packet.calculateChecksum();
  CustomPacket::incrementPacketId(packet.packet_id);

  return packet;
}

//-------------------------------------------------------------------------------------------------------
CustomPacket Peer::create_error_packet(const uint16_t &missing_packet_id) {

  {
    std::lock_guard <std::mutex> lock(cout_mutex);
    std::cout <<"Creating error packet with id: "<<static_cast<int>(missing_packet_id)<< "\n";
  }
  // Create the acknowledgment packet
  CustomPacket error_packet;
  
  error_packet.packet_id = missing_packet_id;
  error_packet.set_error_flag();
  error_packet.set_serialize_flag();
  std::string msg= "error";
  memcpy(error_packet.payload, msg.data(), msg.size());
  error_packet.length = msg.size();
  error_packet.checksum = error_packet.calculateChecksum();

  return error_packet;
}

//-------------------------------------------------------------------------------------------------------
void Peer::add_packets_to_history(const std::map<uint16_t, CustomPacket> &packet_list){
  for (const auto &pair : packet_list) {
    {
      std::lock_guard<std::mutex> lock(packetsToBeSend_mutex);

      while (packetsToBeSend.size() > size_of_packetsToBeSend) {
        auto oldest = packetsToBeSend.begin();
        packetsToBeSend.erase(oldest);
      }

      packetsToBeSend[pair.first] = pair.second;
    }

  }
}

//-------------------------------------------------------------------------------------------------------
void Peer::incrementing_and_checking_packet_id(const uint16_t packet_id_received) {

  std::lock_guard<std::mutex> lock(packet_id_mutex);

  if (this->packet_id < packet_id_received) {
    CustomPacket::incrementPacketId(packet_id);
  } else {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout<< "\tReceived a packet with ID lower then the current one! Keeping current id\n";
  }
}

//-------------------------------------------------------------------------------------------------------
void Peer::adding_messages_in_received_messages(const std::string &msg) {

  {
    std::lock_guard<std::mutex> lock(adding_msg_received);
    messages_received.push_back(msg);

    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout<<"Message added: " << msg <<  std::endl;
    }
  }


  messages_received_cv.notify_one();

}
//-------------------------------------------------------------------------------------------------------

std::string Peer::get_messages_received() {

  std::string msg;
  {
    std::unique_lock<std::mutex> lock(adding_msg_received);
    messages_received_cv.wait(lock, [this] {return !messages_received.empty();});

    msg = *messages_received.begin();
    messages_received.erase(messages_received.begin());
  }
  return msg;

}

void Peer::print_commands_options() {

  std::lock_guard<std::mutex> lock(cout_mutex);
  std::cout << "\nCommands:\n";
  std::cout << "1. Send message\n";
  std::cout << "2. Send file\n";
  std::cout << "3. Exit\n";
  std::cout << "Enter your choice:\n";
}
//-------------------------------------------------------------------------------------------------------

// bool Peer::confirm_file_received() {

//   {
//     std::unique_lock<std::mutex> lock(checking_file_received);
//     checking_file_received_cv.wait(lock, [this] {return checking_file_received;});

//     {
//       std::lock_guard<std::mutex> lock(cout_mutex);
//       std::cout <<"You have received a file. It has been saved in the data folder.\n";
//     }
//   }
//   return true;

// }

//-------------------------------------------------------------------------------------------------------
void Peer::runTerminalInterface() {

  // this->localIPAddress = getLocalIPAddress();
  // if (localIPAddress == "") {
  //     {
  //       std::lock_guard<std::mutex> lock(cout_mutex);
  //       std::cout << "Cannot get IPAddress!!";
  //     }
  //     return;
  // }else {
  //   std::lock_guard<std::mutex> lock(cout_mutex);
  //   std::cout << "IP Address: " << localIPAddress << std::endl;
  // }

  startPeer();

  // Start a thread to listen for incoming packets
  std::thread listener_thread([this]() {
      listenForPackets();
  });

  // Start a thread to print received messages
  std::thread message_printer_thread([this]() {

      // bool var_is_connected;
      // {
      //   std::lock_guard<std::mutex> lock(is_connected_mutex);
      //   var_is_connected = this->is_connected;
      // }
      while (true) {
          
        {
          std::lock_guard<std::mutex> lock(exiting_mutex);
          if (exiting) break;
        }
          std::string received_message = get_messages_received();

          {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "\n[Received Message]: " << received_message << "\n";
          }

          print_commands_options();

        // {
        //   std::lock_guard<std::mutex> lock(is_connected_mutex);
        //   var_is_connected = this->is_connected;
        // }
      }
  });

  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "Welcome to the Peer CLI!\n";
    std::cout << "Choose mode:\n";
    std::cout << "1. Client\n";
  }

  // int mode;
  // std::cin >> mode;

  // bool var_is_connected;
  // {
  //   std::lock_guard<std::mutex>lock(is_connected_mutex);
  //   var_is_connected = is_connected;
  // }
  // if (mode == 1 && !var_is_connected) {

  //   std::string remote_ip;
  //   {
  //       std::lock_guard<std::mutex> lock(cout_mutex);
  //       std::cout << "Enter the server IP: ";
  //   }
  //   std::cin >> remote_ip;
  //   connectToPeer(remote_ip.c_str());
  //   {
  //       std::lock_guard<std::mutex> lock(cout_mutex);
  //       std::cout << "Connected to server at " << remote_ip << ":" << port << "\n";
  //   }
  // } else if (!var_is_connected){
  //     {
  //         std::lock_guard<std::mutex> lock(cout_mutex);
  //         std::cerr << "Invalid mode selected. Exiting...\n";
  //     }
  //     return;
  // }else if (var_is_connected){

  // }

  // bool var_is_connected = false;

  // while (!var_is_connected) {
  //   {
  //     std::lock_guard<std::mutex> lock(is_connected_mutex);
  //     var_is_connected = this->is_connected;
  //   }
  //   std::this_thread::sleep_for(std::chrono::milliseconds(100));
  // }

  bool var_is_connected;

  // Main loop for user commands
  while (true) {
      
    //********************************** */
    //blocking sequence
    {
      std::lock_guard<std::mutex> lock(exiting_mutex);
      if (exiting) break;
    }

    {
      std::lock_guard<std::mutex>lock(is_connected_mutex);
      var_is_connected = this->is_connected;
    }

    if (!var_is_connected) {

      {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "Welcome to the Peer CLI!\n";
        std::cout << "Choose mode:\n";
        std::cout << "1. Client\n";
      }

      int mode;
      std::cin >> mode;
      
      if (mode == 1) {
        std::string remote_ip;
        {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "Enter the server IP: ";
        }
        std::cin >> remote_ip;
        connectToPeer(remote_ip.c_str());
        {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "Connected to server at " << remote_ip << ":" << port << "\n";
        }
      } else {
        {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cerr << "Invalid mode selected. Exiting...\n";
        }
        return;
      }
    } else {

      print_commands_options();

      int choice;
      std::cin >>choice;

      // Validate input
      if (std::cin.fail()) {
          std::cin.clear(); // Clear the error flag
          std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Discard invalid input
          {
              std::lock_guard<std::mutex> lock(cout_mutex);
              std::cerr << "Invalid choice. Please try again.\n";
          }
          continue;
      }

      if (choice == 1) {
          // Send a message
          std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Clear the newline character
          std::string message;
          {
              std::lock_guard<std::mutex> lock(cout_mutex);
              std::cout << "Enter your message: ";
          }
          std::getline(std::cin, message);
          sendMessage(message);
      } else if (choice == 2) {
          // Send a file
          std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Clear the newline character
          std::string file_path;
          {
              std::lock_guard<std::mutex> lock(cout_mutex);
              std::cout << "Enter the file path: ";
          }
          std::getline(std::cin, file_path);
          sendFile(file_path);
      } else if (choice == 3) {
          {
              std::lock_guard<std::mutex> lock(cout_mutex);
              std::cout << "Exiting...\n";
          }
          endConnection();
          break;
      } else {
          {
              std::lock_guard<std::mutex> lock(cout_mutex);
              std::cerr << "Invalid choice. Please try again.\n";
          }
      }
    }

      
    //   // Non-blocking input
    //   while (true) {
    //       {
    //           std::lock_guard<std::mutex> lock(exiting_mutex);
    //           if (exiting) break; // Exit the loop if the `exiting` flag is set
    //       }

    //       if (std::cin.peek() != EOF) { // Check if input is available
    //           std::cin >> choice;
    //           break;
    //       }

    //       // Sleep briefly to avoid busy-waiting
    //       std::this_thread::sleep_for(std::chrono::milliseconds(100));
    //   }

    // {
    //     std::lock_guard<std::mutex> lock(exiting_mutex);
    //     if (exiting) break; // Exit the loop if the `exiting` flag is set
    // }
      // // Validate input
      // if (std::cin.fail()) {
      //     std::cin.clear(); // Clear the error flag
      //     std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Discard invalid input
      //     {
      //         std::lock_guard<std::mutex> lock(cout_mutex);
      //         std::cerr << "Invalid choice. Please try again.\n";
      //     }
      //     continue;
      // }

      // if (choice == 1) {
      //     // Send a message
      //     std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Clear the newline character
      //     std::string message;
      //     {
      //         std::lock_guard<std::mutex> lock(cout_mutex);
      //         std::cout << "Enter your message: ";
      //     }
      //     std::getline(std::cin, message);
      //     sendMessage(message);
      // } else if (choice == 2) {
      //     // Send a file
      //     std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Clear the newline character
      //     std::string file_path;
      //     {
      //         std::lock_guard<std::mutex> lock(cout_mutex);
      //         std::cout << "Enter the file path: ";
      //     }
      //     std::getline(std::cin, file_path);
      //     sendFile(file_path);
      // } else if (choice == 3) {
      //     {
      //         std::lock_guard<std::mutex> lock(cout_mutex);
      //         std::cout << "Exiting...\n";
      //     }
      //     endConnection();
      //     break;
      // } else {
      //     {
      //         std::lock_guard<std::mutex> lock(cout_mutex);
      //         std::cerr << "Invalid choice. Please try again.\n";
      //     }
      // }

    // {
    //   std::lock_guard<std::mutex> lock(is_connected_mutex);
    //   var_is_connected = this->is_connected;
    // }

  }

  // Wait for the listener thread to finish
  if (listener_thread.joinable()) {
      listener_thread.join();
  }

  // Wait for the message printer thread to finish
  if (message_printer_thread.joinable()) {
      message_printer_thread.detach(); // Detach the thread to allow it to exit independently
  }

  std::this_thread::sleep_for(std::chrono::milliseconds(100));
  exit(0);
}

//-------------------------------------------------------------------------------------------------------
void Peer::ensureDataFolderExists() {

    // Check if the folder exists
    if (!std::filesystem::exists(folder_name)) {
        // Create the folder
        if (mkdir(folder_name.c_str(), 0777) == 0) {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "Folder 'data' created successfully.\n";
        } else {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "Error: Could not create folder 'data'.\n";
        }
    }else {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout<<"Folder exists.\n";
    }
}

//-------------------------------------------------------------------------------------------------------
// I need to use this function in setting up the ip address, currently I use constants;
// I need to not use the port as a hard codded value
std::string Peer::getLocalIPAddress() const {
    struct ifaddrs *ifaddr, *ifa;
    char host[NI_MAXHOST];
    std::vector<std::string> ip_addresses;

    if (getifaddrs(&ifaddr) == -1) {
        perror("getifaddrs");
        return "";
    }

    for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == nullptr) continue;

        if (ifa->ifa_addr->sa_family == AF_INET) { // Check for IPv4
            if (getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in),
                            host, NI_MAXHOST, nullptr, 0, NI_NUMERICHOST) == 0) {
                if (std::string(ifa->ifa_name) != "lo") { // Skip loopback interface
                    ip_addresses.push_back(std::string(host));
                }
            }
        }
    }

    freeifaddrs(ifaddr);

    if (ip_addresses.empty()) {
        std::cerr << "No available IP addresses found.\n";
        return "";
    }

    if (ip_addresses.size() == 1) {
      return ip_addresses[0];
    }

    // Display the available IP addresses and let the user choose
    std::cout << "Available IP addresses:\n";
    for (size_t i = 0; i < ip_addresses.size(); ++i) {
        std::cout << i + 1 << ". " << ip_addresses[i] << "\n";
    }

    int choice = 0;
    while (true) {
        std::cout << "Enter the number corresponding to the IP address you want to use: ";
        std::cin >> choice;

        if (std::cin.fail() || choice < 1 || choice > static_cast<int>(ip_addresses.size())) {
            std::cin.clear(); // Clear the error flag
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Discard invalid input
            std::cerr << "Invalid choice. Please try again.\n";
        } else {
            break;
        }
    }

    return ip_addresses[choice - 1];
}#include <cstdint> // For uint8_t, uint16_t
#include <cstring> // For memcpy
#include <iostream>
#include <map>
#include <vector>
#include <thread>
#include <chrono>
#include <mutex>
#include <condition_variable>

#include "CustomPacket.h"
#include "MissingPacketsException.h"
#include "Peer.h"
#include "imgui/imgui.h"
#include "imgui/backends/imgui_impl_glfw.h"
#include "imgui/backends/imgui_impl_opengl3.h"
#include <GLFW/glfw3.h>
#include <thread>
#include <vector>
#include <string>

std::mutex cout_mutex;

// flags:
// bit7  bit6    bit5      bit4       bit3       bit2        bit1   bit0 
// enc ---  msg_type  start_trans  end_trans   series     ACK       URGENT
//
//
// msg_type: 0 text, 1 file
//  Define Packet Structure

void print_and_verify_bits0_5(CustomPacket packet) {
  std::cout << "Initial MsgType: " << packet.getMsgType() << std::endl;
  packet.setMsgType(1); // File
  std::cout << "Updated MsgType: " << packet.getMsgType() << std::endl;

  std::cout << "Initial ACK flag: " << packet.get_ack_flag() << std::endl;
  packet.set_ack_flag();
  std::cout << "Updated ACK flag: " << packet.get_ack_flag() << std::endl;

  std::cout << "Initial End Transmission flag: " << packet.get_end_transmition_flag() << std::endl;
  packet.set_end_transmition_flag();
  std::cout << "Updated End Transmission flag: " << packet.get_end_transmition_flag() << std::endl;

  std::cout << "Initial Start Transmission flag: " << packet.get_start_transmition_flag() << std::endl;
  packet.set_start_transmition_flag();
  std::cout << "Updated Start Transmission flag: " << packet.get_start_transmition_flag() << std::endl;

  std::cout << "Initial Urgent flag: " << packet.get_urgent_flag() << std::endl;
  packet.set_urgent_flag();
  std::cout << "Updated Urgent flag: " << packet.get_urgent_flag() << std::endl;
}

void test_packet_serialization() {
  // Create a test packet
  CustomPacket packet;
  packet.packet_id = 1;
  packet.setMsgType(0); // Text message
  packet.set_ack_flag();
  packet.set_start_transmition_flag();
  strcpy(packet.payload, "Hello, custom protocol!"); // Set payload
  packet.length = strlen(packet.payload);           // Set length
  packet.checksum = packet.calculateChecksum();     // Calculate checksum

  // Print the original packet details
  std::cout << "Original Packet Details:\n";
  std::cout << "Packet ID: " << packet.packet_id << "\n";
  std::cout << "Message Type: " << (int)packet.getMsgType() << "\n";
  std::cout << "Payload: " << packet.payload << "\n";
  std::cout << "Length: " << packet.length << "\n";
  std::cout << "Checksum: " << packet.checksum << "\n";
  packet.printFlags();

  // Serialize the packet
  uint8_t buffer[sizeof(CustomPacket)];
  packet.serialize(buffer);

  // Deserialize the packet
  CustomPacket received = CustomPacket::deserialize(buffer);

  // Print the deserialized packet details
  std::cout << "\nDeserialized Packet Details:\n";
  std::cout << "Packet ID: " << received.packet_id << "\n";
  std::cout << "Message Type: " << (int)received.getMsgType() << "\n";
  std::cout << "Payload: " << received.payload << "\n";
  std::cout << "Length: " << received.length << "\n";
  std::cout << "Checksum: " << received.checksum << "\n";
  received.printFlags();

  // Verify the deserialized packet
  if (received.packet_id == packet.packet_id &&
      received.getMsgType() == packet.getMsgType() &&
      strcmp(received.payload, packet.payload) == 0 &&
      received.length == packet.length &&
      received.checksum == packet.checksum) {
    std::cout << "\nTest passed: Packet serialization and deserialization are correct.\n";
  } else {
    std::cout << "\nTest failed: Packet serialization and deserialization are incorrect.\n";
  }
}

void test_fragment_and_compose_message() {
  // Create a long message to be fragmented
  std::string long_message = "Site-ul are n pagina (pagina textit) dou butoare disponibile extit iextit, al doilea "
                             "fiind pentru crearea de utilizator nou al aplicaiei (orice utilizator va trebui s-i fac cont pentru a putea cumpra bilete), "
                             "iar primul pentru a te conecta la un cont deja existent. "
                             "Pentru conectarea la un cont este nevoie doar de textiti de textit{parola} contului. Conectarea la un cont ne va oferi "
                             "posibilitatea de a vizualiza istoricul biletelor cumprate (dac exist), cursele ce vor avea loc i lista locurilor libere din avion. "
                             "Prin apsarea pe un loc liber, acel bilet va fi adaugat n coul utilizatorului. Aceast aciune poate fi repetat pentru posibilitatea "
                             "cumprrii a multiple bilete simultan. "
                             "Dac n co se afl cel puin un bilet, vor aprea dou butoane: textit{} i textit{}, ce vor oferi posibilitatea de a terge din coul "
                             "curent biletul selectat, dar i de a finaliza cumprarea, adugnd biletele n istoric i golind coul.";
  uint16_t packet_id = 0;

  // Fragment the message
  std::map<uint16_t, CustomPacket> fragmented_packets = CustomPacket::fragmentMessage(long_message, packet_id);

  // Print fragmented packets
  std::cout << "Fragmented Packets:\n";
  for (const auto &pair : fragmented_packets) {
    const CustomPacket &packet = pair.second;
    std::cout << "Packet ID: " << packet.packet_id << ", Payload: " << packet.payload << ", Checksum: " << packet.checksum << ", length: "<< packet.length<<"\n\n";
  }

  // fragmented_packets.erase(2);
  if (fragmented_packets.find(2) != fragmented_packets.end()){
    fragmented_packets[2].checksum = 1243;
  }
  std::cout << "Fragmented Packets:\n";
  for (const auto &pair : fragmented_packets) {
    const CustomPacket &packet = pair.second;
    std::cout << "Packet ID: " << packet.packet_id << ", Payload: " << packet.payload << ", Checksum: " << packet.checksum << ", length: "<< packet.length<<"\n\n";
  }


  try {
  // Compose the message from fragmented packets
  std::string composed_message = CustomPacket::composedMessage(fragmented_packets);

  // Print the composed message
  std::cout << "\n\nComposed Message: " << composed_message << "\n";
  std::cout << "Composed Message size: " << composed_message.length() << "\n";


  } catch (const MissingPacketsException& e) {
    std::cerr <<"Error: " << e.what() <<std::endl;
    const std::vector<uint16_t>& missing_packets = e.getMissingPackets();

    for (const uint16_t missing_packet_id : missing_packets) {
      std::cout<<missing_packet_id << std::endl;
    }

  }catch (const std::exception& e) {
    std::cerr<<"Error: " << e.what()<<std::endl;
  }

}

void test_peer_class() {
  // Mutex and condition variable for thread synchronization
  std::mutex sync_mutex;
  std::condition_variable server_ready_cv;
  bool server_ready = false;

  // Mutex for thread-safe output
  std::mutex cout_mutex;

  // Peer 1: Server
  std::thread server_thread([&]() {
    Peer server_peer;
    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout << "Starting server peer on port 8080...\n";
    }

    // Start the server
    server_peer.startPeer();

    // Notify the client that the server is ready
    {
      std::lock_guard<std::mutex> lock(sync_mutex);
      server_ready = true;
    }
    server_ready_cv.notify_one();

    // Keep the server running
    std::this_thread::sleep_for(std::chrono::seconds(10)); // Simulate server activity
    // server_peer.endConnection();
    // std::this_thread::sleep_for(std::chrono::seconds(3)); // Simulate server activity
  });

  // Peer 2: Client
  std::thread client_thread([&]() {
    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout << "Client thread started.\n";
    }

    // Wait for the server to be ready
    {
      std::unique_lock<std::mutex> lock(sync_mutex);
      server_ready_cv.wait(lock, [&]() { return server_ready; });
    }

    Peer client_peer;
    {
      std::lock_guard<std::mutex> lock(cout_mutex);
      std::cout << "Starting client peer...\n";
    }

    // Start the client and send a message
    client_peer.startPeer();
    client_peer.sendMessage("Site-ul are n pagina (pagina textit) dou butoare disponibile extit iextit, al doilea "
                             "fiind pentru crearea de utilizator nou al aplicaiei (orice utilizator va trebui s-i fac cont pentru a putea cumpra bilete), "
                             "iar primul pentru a te conecta la un cont deja existent. "
                             "Pentru conectarea la un cont este nevoie doar de textiti de textit{parola} contului. Conectarea la un cont ne va oferi "
                             "posibilitatea de a vizualiza istoricul biletelor cumprate (dac exist), cursele ce vor avea loc i lista locurilor libere din avion. "
                             "Prin apsarea pe un loc liber, acel bilet va fi adaugat n coul utilizatorului. Aceast aciune poate fi repetat pentru posibilitatea "
                             "cumprrii a multiple bilete simultan. "
                             "Dac n co se afl cel puin un bilet, vor aprea dou butoane: textit{} i textit{}, ce vor oferi posibilitatea de a terge din coul "
                             "curent biletul selectat, dar i de a finaliza cumprarea, adugnd biletele n istoric i golind coul.");
    std::this_thread::sleep_for(std::chrono::seconds(3));
    client_peer.sendMessage("   Site-ul are n pagina (pagina textit) dou butoare disponibile extit iextit, al doilea "
                             "fiind pentru crearea de utilizator nou al aplicaiei (orice utilizator va trebui s-i fac cont pentru a putea cumpra bilete), "
                             "iar primul pentru a te conecta la un cont deja existent. "
                             "Pentru conectarea la un cont este nevoie doar de textiti de textit{parola} contului. Conectarea la un cont ne va oferi "
                             "posibilitatea de a vizualiza istoricul biletelor cumprate (dac exist), cursele ce vor avea loc i lista locurilor libere din avion. "
                             "Prin apsarea pe un loc liber, acel bilet va fi adaugat n coul utilizatorului. Aceast aciune poate fi repetat pentru posibilitatea "
                             "cumprrii a multiple bilete simultan. ");

    std::this_thread::sleep_for(std::chrono::seconds(3)); // Simulate server activity
    client_peer.endConnection();
  });

  // Wait for both threads to finish
  server_thread.join();
  client_thread.join();

  {
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "Peer test completed.\n";
  }
}

// Global variables for the chat interface
std::vector<std::string> chat_messages;
std::string input_message;
std::string ip_address = "127.0.0.1"; // Default IP address
bool exit_exit = false;

// Function to initialize Dear ImGui
void initImGui(GLFWwindow* window) {
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init("#version 130");
    ImGui::StyleColorsDark();
}

// Function to clean up Dear ImGui
void cleanupImGui() {
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
}

// Function to render the GUI
bool renderGUI(Peer& peer) {
  bool var_is_connected;
  {
    std::lock_guard<std::mutex>lock(peer.is_connected_mutex);
    var_is_connected = peer.is_connected;
  }
    if (!var_is_connected) {

        // Connection screen
        ImGui::Begin("Connect to Peer");
        ImGui::Text("Enter the IP address of the peer you want to connect to:");

        // Input box for IP address
        static char ip_buffer[16] = "192.168.0.114"; // Buffer for IP address (max length 15 + null terminator)
        ImGui::InputText("IP Address", ip_buffer, sizeof(ip_buffer));

        // Connect button
        if (ImGui::Button("Connect")) {
            std::string ip_address(ip_buffer);

            {
              std::lock_guard<std::mutex>lock(peer.cout_mutex);
              std::cout<<"Connecting\n";
            }

            // Validate IP address length
            if (ip_address.length() >= 7 && ip_address.length() <= 15) {

                {
                  std::lock_guard<std::mutex>lock(peer.cout_mutex);
                  std::cout<<"Valid ip\n";
                }

                peer.connectToPeer(ip_address.c_str());
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                {
                  std::lock_guard<std::mutex>lock(peer.is_connected_mutex);
                  var_is_connected = peer.is_connected;
                }
                if (var_is_connected) {
                    ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Connected successfully!");
                } else {
                    ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Failed to connect. Please try again.");
                }
            } else {

                {
                  std::lock_guard<std::mutex>lock(peer.cout_mutex);
                  std::cout<<"Invalid IP :(\n";
                }

                // Display an error message if the IP address is invalid
                ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Invalid IP address length! Must be between 4 and 12 characters.");
            }
        }

        ImGui::End();
    } else {

        exit_exit = true;

        // Chat screen
        ImGui::Begin("Chat Interface", nullptr, ImGuiWindowFlags_NoResize);

        // Display chat messages
        ImGui::BeginChild("ChatWindow", ImVec2(0, ImGui::GetWindowHeight() - 150), true);
        for (const auto& message : chat_messages) {
            ImGui::TextWrapped("%s", message.c_str());
        }
        ImGui::EndChild();

        // Input box for sending messages
        static std::string message_buffer; // Use std::string for dynamic allocation
        char input_buffer[1024];           // Temporary buffer for ImGui input

        // Copy the current content of message_buffer to input_buffer
        strncpy(input_buffer, message_buffer.c_str(), sizeof(input_buffer));
        input_buffer[sizeof(input_buffer) - 1] = '\0'; // Ensure null termination

        if (ImGui::InputText("Message", input_buffer, sizeof(input_buffer))) {
            // Update message_buffer with the new input
            message_buffer = input_buffer;
        }

        if (ImGui::Button("Send")) {
            if (!message_buffer.empty()) {
                peer.sendMessage(message_buffer); // Send the message
                chat_messages.push_back("You: " + message_buffer); // Add to chat history
                message_buffer.clear(); // Clear the input buffer
            }
        }

        // Input box for file location
        static char file_buffer[512] = ""; // Buffer for file path input
        ImGui::InputText("File Path", file_buffer, sizeof(file_buffer));
        if (ImGui::Button("Send File")) {
            std::string file_path(file_buffer);
            peer.sendFile(file_path);
            chat_messages.push_back("You sent a file: " + file_path);
            memset(file_buffer, 0, sizeof(file_buffer)); // Clear the input buffer
        }

        // Back button to disconnect and return to the connection screen
        if (ImGui::Button("Back")) {
            peer.endConnection(); // End the connection
            chat_messages.clear(); // Clear chat messages
              std::this_thread::sleep_for(std::chrono::milliseconds(200));
          {
            std::lock_guard<std::mutex> lock(peer.is_connected_mutex);
            peer.is_connected = false;
          }
          return false;
        }

        ImGui::End();
    }

    bool is_con = false;
    {
      std::lock_guard<std::mutex> lock(peer.is_connected_mutex);
      is_con = peer.is_connected;
    }

    bool exitin = false;
    {
      std::lock_guard<std::mutex> lock(peer.exiting_mutex);
      exitin = peer.exiting;
    }

    if (!is_con && exitin) {
      chat_messages.clear(); // Clear chat messages
      return false;
    }

    return true;
}

int main() {
    
  while (true){
    {

      // Initialize Peer
      Peer peer;

      peer.startPeer();

      // Start a thread to listen for incoming packets
      std::thread listener_thread([&peer]() {
          peer.listenForPackets();
      });

      std::thread processor_thread([&peer]() {
        peer.processPackets();
      });

      // Start a thread to print received messages
      std::thread message_printer_thread([&peer]() {

          // bool var_is_connected;
          // {
          //   std::lock_guard<std::mutex> lock(is_connected_mutex);
          //   var_is_connected = this->is_connected;
          // }
          while (true) {
            std::string received_message = peer.get_messages_received();

            if (received_message == "Aw12@0986^12luAwCluhWQ123~~``!") {
              {
                std::lock_guard<std::mutex> lock(peer.cout_mutex);
                std::cout << "Received wierd message\n";
              }
              break;
            }

              {
                std::lock_guard<std::mutex> lock(peer.cout_mutex);
                std::cout << "\n[Received Message]: " << received_message << "\n\n";
              }

              std::this_thread::sleep_for(std::chrono::milliseconds(100));

              chat_messages.push_back(received_message);
              // for (const auto &msg :peer.messages_received) {
              //   std::lock_guard<std::mutex> lock(peer.cout_mutex);
              //   // std::lock_guard<std::mutex> lock(peer.adding_msg_received);
              //   std::cout<<msg<<std::endl;
              // }

              // print_commands_options();

            // {
            //   std::lock_guard<std::mutex> lock(is_connected_mutex);
            //   var_is_connected = this->is_connected;
            // }
          }
      });

      // Initialize GLFW
      if (!glfwInit()) {
          return -1;
      }

      // Create a windowed mode window and its OpenGL context
      GLFWwindow* window = glfwCreateWindow(800, 600, "Peer Chat", NULL, NULL);
      if (!window) {
          glfwTerminate();
          return -1;
      }

      glfwMakeContextCurrent(window);
      glfwSwapInterval(1);

      // Initialize Dear ImGui
      initImGui(window);

      // Main loop
      while (!glfwWindowShouldClose(window)) {
          glfwPollEvents();

          // Start the Dear ImGui frame
          ImGui_ImplOpenGL3_NewFrame();
          ImGui_ImplGlfw_NewFrame();
          ImGui::NewFrame();

          // Render the GUI
          if (!renderGUI(peer)) break;

          // Rendering
          ImGui::Render();
          int display_w, display_h;
          glfwGetFramebufferSize(window, &display_w, &display_h);
          glViewport(0, 0, display_w, display_h);
          glClearColor(0.45f, 0.55f, 0.60f, 1.00f);
          glClear(GL_COLOR_BUFFER_BIT);
          ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

          glfwSwapBuffers(window);
      }

      // Cleanup
      cleanupImGui();
      glfwDestroyWindow(window);
      glfwTerminate();

      // Wait for the listener thread to finish
      if (listener_thread.joinable()) {
          listener_thread.join();
          std::cout << "[Thread Ended]: Listener thread has finished.\n";
      }

      // Wait for the processor thread to finish
      if (processor_thread.joinable()) {
          processor_thread.join();
          std::cout << "[Thread Ended]: Processor thread has finished.\n";
      }

      // Wait for the message printer thread to finish
      if (message_printer_thread.joinable()) {
          message_printer_thread.join();
          std::cout << "[Thread Ended]: Message printer thread has finished.\n";
      }

      std::cout << "End";

      std::this_thread::sleep_for(std::chrono::seconds(1));
    }
  }
    return 0;
}

#!/bin/bash

# Function to check and install a package
check_and_install() {
    PACKAGE=$1
    if ! dpkg -s $PACKAGE >/dev/null 2>&1; then
        echo "$PACKAGE is not installed. Installing..."
        sudo apt-get install -y $PACKAGE
    else
        echo "$PACKAGE is already installed."
    fi
}

# Check and install required packages
check_and_install libglfw3
check_and_install libglfw3-dev
check_and_install libgl1-mesa-dev
check_and_install libx11-dev

# g++ -o main ./main.cpp CustomPacket.cpp Peer.cpp -lglfw -lGL -pthread
g++ -o main main.cpp Peer.cpp CustomPacket.cpp \
    imgui/imgui.cpp imgui/imgui_draw.cpp imgui/imgui_tables.cpp imgui/imgui_widgets.cpp \
    imgui/backends/imgui_impl_glfw.cpp imgui/backends/imgui_impl_opengl3.cpp \
    -Iimgui -Iimgui/backends -lglfw -lGL -pthread
# sudo ./main
XDG_RUNTIME_DIR=/tmp/$USER-runtime-dir sudo ./main
rm main
